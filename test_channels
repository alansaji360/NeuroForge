import tkinter as tk
from tkinter.ttk import *
from tkinter import messagebox
from tkinter import filedialog
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import serial
import struct
import threading

class App():
    def __init__(self):
        self.root = None
        self.root = tk.Tk()
        self.root.geometry("400x400")
        self.root.protocol("WM_DELETE_WINDOW", self.callback)
        self.plot = None
        self.mainMenu()

    def callback(self):
        if self.plot is not None:
            self.plot.__del__()
        self.root.quit()

    def clearWindow(self):
        for widget in self.root.winfo_children():
            widget.destroy()

    def toggleLivePlot(self):
        self.clearWindow()
        self.plot = LivePlot(self.root, n_channels=4)

    def mainMenu(self):
        style = Style()
        style.configure("TButton", padding=6, relief="flat", background="#20b2aa", activebackground="#20b2aa")

        Live = Button(self.root, text ="LivePlot", command = self.toggleLivePlot, style="TButton")
        Live.pack(expand=True)

        exit_button = Button(self.root, text = "Exit", command = exit, style="TButton") 
        exit_button.pack(expand=True)

        self.root.mainloop()

class LivePlot():
    def __init__(self, root, n_channels=4):
        """Initialize Live_Plot object"""
        self.root = root
        
        self.COM_PORT = 'COM3'          # Change to your COM port
        self.BAUD_RATE = 115200         # Change to the appropriate baud rate
        self.NUM_SAMPLES = 64           # Number of bytes to read (32 bytes = 16 samples)
        self.SAMPLE_RATE = 18000        # Define the sampling rate (Hz)
        self.NUM_CHANNELS = n_channels  # Number of channels to read
        self.BUFFER_SIZE = 10240        # Buffer size

        self.fig, self.ax = plt.subplots(self.NUM_CHANNELS, figsize=(10, 8), dpi=100)
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().pack()

        self.data_buffer = np.zeros((self.NUM_CHANNELS, self.BUFFER_SIZE))

        try:
            self.ser = serial.Serial(self.COM_PORT, self.BAUD_RATE, timeout=1)
            self.ser.set_buffer_size(rx_size=8192, tx_size=8192)
        except serial.SerialException as e:
            print(f"Error: {e}")
            tk.messagebox.showerror("Serial Error", f"Could not open serial port: {e}")
            self.ser = None

        self.sample_index = 0
        self.stop_event = threading.Event()  # Event to stop the thread

        self.read_thread = threading.Thread(target=self.readSerialData)
        self.read_thread.start()

        self.updatePlot()

    def readSerialData(self):
        """Read data from serial in a separate thread."""
        while not self.stop_event.is_set():
            if self.ser.in_waiting >= self.NUM_SAMPLES:
                data = self.ser.read(self.NUM_SAMPLES)
                samples = struct.unpack('<32H', data)
                
                skip = int(self.NUM_SAMPLES / 2)
                for i in range(self.NUM_CHANNELS):
                    self.data_buffer[i][:-skip] = self.data_buffer[i][skip:]
                    self.data_buffer[i][-skip:] = samples

                self.sample_index += skip

    def updatePlot(self):
        """Update the plot with the latest data."""
        if self.sample_index > 0:
            for i in range(self.NUM_CHANNELS):
                self.ax[i].clear()
                self.ax[i].plot(self.data_buffer[i], color='b')
                self.ax[i].set_title(f"Channel {i+1}")
                self.ax[i].set_xlabel('Samples')
                self.ax[i].set_ylabel('Amplitude')
                self.ax[i].set_ylim(-1000, 4500)

            self.canvas.draw()

        self.root.after(1, self.updatePlot)

    def __del__(self):
        """Cleanup resources and stop threads."""
        self.stop_event.set()  
        if self.ser and self.ser.is_open:  
            self.ser.close()

if __name__ == '__main__':
        app = App()